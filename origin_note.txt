題目: 1. twosum
類型: array, hash
筆記:
一個陣列中想要找兩個數字合=target的 
暴力解O(n^2)就是兩個for迴圈 
可以做到O(n) 將target扣掉原本的陣列 得到每個數字理想要匹配到的數字
利用hash可以O(1)搜尋一個陣列的能力 搜尋只需要n個O(1)
程式碼:     
    //brute force
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {}; // No solution found
    }
    //hash
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            if (numMap.count(complement)) {
                return {numMap[complement], i};
            }
            numMap[nums[i]] = i;
        }

        return {}; // No solution found
    }

題目: 238. Product of Array Expect Self 
類型: array, algorithm
筆記:
這題要O(n)時間對一個陣列輸出除了那一項以外的乘積
用兩個for迴圈 從左往右跑一次 用一個leftproduct紀錄左邊的所有乘積 放到asnwer[i]裡面
右往左也一樣 乘到asnwer裡面 這樣每一個就是除了自己以外的左邊和右邊所有的乘積相乘
程式碼:     
    vector<int> productExceptSelf(vector<int>& nums) {
    vector<int> answer(nums.size(),1);
    int leftproduct=1;
    for(int i=0;i<nums.size();++i)
    {
        answer[i]=leftproduct;
        leftproduct*=nums[i];
    }
    int rightproduct=1;
    for(int i=nums.size()-1;i>=0;--i)
    {
        answer[i]*=rightproduct;
        rightproduct*=nums[i];
    }
    return answer;
    }

題目: 26. Remove Duplicates from Sorted Array
類型: array, algorithm
筆記:
用now紀錄當前值 用for掃過一遍記下不同值而已
程式碼:
    int removeDuplicates(vector<int>& nums) {
        int now=-999;
        vector<int> temp;
        for(int i=0;i<nums.size();++i)
        {
            if(now==nums.at(i))
            {
                //do nothing
            }
            else
            {
                now=nums.at(i);
                temp.push_back(nums.at(i));
            }
        }
        int k = temp.size();
        nums = temp;
        return k;
    }

題目: 80. Remove Duplicates from Sorted Array II
類型: array, algorithm
筆記:
跟前一題差不多 多一個count紀錄現在這是第幾個數確保最多兩個
程式碼:
    int removeDuplicates(vector<int>& nums) {
        int count=0;
        int now=-9999;
        vector<int> ans;
        for(int i=0;i<nums.size();++i)
        {
            if(now!=nums.at(i)) //different from last one
            {
                count=1;
                now=nums.at(i);
                ans.push_back(now);
            }
            else if(now==nums.at(i))
            {
                if(count==1)
                {
                    ++count;
                    ans.push_back(now);
                }
                else if(count==2)
                {
                    //do nothing
                }
            }

        }
        nums=ans;
        return nums.size();
    }

題目: 283. Move Zeros
類型: array, 雙指針
筆記:
用兩個指針標記目前處理到哪 存到哪 就不用多開一個array存結果 節省空間
程式碼:
    void moveZeroes(vector<int>& nums) {
        int count_zero=0;
        int now=0;
        for(int i=0;i<nums.size();++i)
        {
            if(nums.at(i)==0)
            {
                count_zero++;
            }
            else
            {
                nums.at(now)=nums.at(i);
                now++;
            }
        }
        for(int i=now;i<nums.size();++i)
        {
            nums.at(i)=0;
        }
    }

題目: 349. Intersection of Two Arrays
類型: array 雙指針
筆記:
sort過後就和前面幾題差不多 比較兩個指標相同就放進來 不同就小的往後移
程式碼:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        int now1=0, now2=0;
        vector<int> ans;
        int temp=-1;
        while(now1<nums1.size() && now2<nums2.size())
        {
            if(nums1.at(now1) == nums2.at(now2))
            {
                if(temp==nums1.at(now1))
                {
                    now1++;
                    now2++;
                }
                else
                {
                    ans.push_back(nums1.at(now1));
                    temp=nums1.at(now1);
                    now1++;
                    now2++;
                }
            }
            else if(nums1.at(now1) > nums2.at(now2))
            {
                now2++;
            }
            else if(nums1.at(now1) < nums2.at(now2))
            {
                now1++;
            }
        }
        return ans;
    }

題目: 136. Single Number
類型: array, bit operation
筆記:
最快可以O(n) 利用a^1=a a^a=1的特性 兩個相同值的會被削掉 for迴圈掃過一遍就剩下單個值的
程式碼:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int num: nums)
        {
            result=result ^ num;
        }

        return result;
    }

題目: 11. Container With Most Water
類型: array, 雙指針
筆記:
決定水高的是矮的那邊 從最左和右邊開始往內縮 每次往內縮都移動矮的那邊
程式碼:
    int water(int l, int r, int dis)
    {
        return min(l, r) * dis;
    }
    int maxArea(vector<int>& height) {
        int left=0, right=height.size()-1;
        int maxarea=water(height[left], height[right], right-left);
        while(left<right)
        {
            if(height[left]<=height[right]) //左小
            {
                left++;
                int temp=water(height[left], height[right], right-left);
                if(temp>maxarea) maxarea=temp;
            
            }
            else if(height[left]>height[right]) //左大
            {
                right--;
                int temp=water(height[left], height[right], right-left);
                if(temp>maxarea) maxarea=temp;
            }
        }
        return maxarea;
    }

題目: 209. Minimum Size Subarray Sum
類型: array, sliding window
筆記:
從最左邊開始 有兩個指標left和right 從left到right的總和<target就right往右找 
如果太大left往右縮小範圍 O(n)就可以找過所有可能
程式碼:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = numeric_limits<int>::max();
        int left = 0;
        int curSum = 0;
        for (int right = 0; right < nums.size(); right++) {
            curSum += nums[right];
            while (curSum >= target) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                }
                curSum -= nums[left];
                left++;
            }
        }
        return minLen != numeric_limits<int>::max() ? minLen : 0;        
    }

題目: 643. Maximum Average Subarray I
類型: array, sliding window
筆記:
跟前一題差不多 subarray的題目都可以考慮用sliding window去解
程式碼:
    double findMaxAverage(vector<int>& nums, int k) {
        int left=0,right=k-1;
        int sum=0;
        for(int i=0;i<=right;++i)
        {
            sum=sum+nums[i];
        }
        double ans=sum;
        for(int i=0;i<nums.size()-k;++i)
        {
            right++;
            sum=sum-nums[left]+nums[right];
            left++;
            if(ans<sum) ans=sum;

        }
        return ans/k;
    }

題目: 15. 3Sum
類型: array 雙指針
筆記:
雙指針的延伸 三個指標left mid right 限制left的情況下mid right跑雙指針 
這題要注意重複解要刪掉 left++後如果left=left-1就跳過
程式碼:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int left,mid,right;
        vector <vector<int>> ans;
        int mid_temp=9999;
        for(left=0;left<nums.size()-2;++left)
        {
            while(left!=0 && nums[left]==nums[left-1]) 
            {
                ++left;
                if(left==nums.size()-2) return ans;
            }
            mid=left+1;
            right=nums.size()-1;
            int target=nums[left]*-1;
            while(mid<right)
            {
                int sum = nums[mid]+nums[right];
                if(sum>target) right--;
                else if(sum<target) mid++;
                else 
                {
                    vector<int> num={nums[left], nums[mid], nums[right]};
                    ans.push_back(num);
                    mid_temp = nums[mid];
                    while(nums[mid]==mid_temp)
                    {
                        mid++;
                        if(mid==nums.size()-1) break;
                    }
                }
            }
        }
        return ans;
    }

題目: 16. 3Sum Closest
類型: array 雙指針
筆記:
跟前一題一樣的作法 用三個指針 固定左邊 跑mid right
程式碼:
    int threeSumClosest(vector<int>& nums, int target) {
        int left=0, mid, right;
        int ans=999999;
        sort(nums.begin(), nums.end());
        for(left=0; left<nums.size()-2;++left)
        {
            mid=left+1;
            right=nums.size()-1;
            while(mid<right)
            {
                int sum=nums[left]+nums[mid]+nums[right];
                if(abs(sum, target)<abs(ans, target)) ans=sum;
                if(target-sum>0)
                {
                    mid++;
                }
                else if(target-sum<0)
                {
                    right--;
                }
                else return ans;
            }
        }
        return ans;
    }

題目: 704. binary search
類型: array search
筆記:
停止條件設為while(left<=right) 中間的移動方式設為mid+1或-1 跑完迴圈就不用再作其他檢查
要小心mid計算時要用left+(right-left)/2 避免left+right可能會overflow
程式碼:
    int search(vector<int>& nums, int target) {
        int left=0, right=nums.size()-1;
        while(left<=right)
        {
            int num=(left+right)/2;
            if(nums[num]==target) return num;
            else if(nums[num]>target) right=num-1;
            else left=num+1;
        }
        return -1;
    }

題目: 278. First Bad Version
類型: array search
筆記:
一般的binary search改成用函式判斷停止條件而已
程式碼:
    int firstBadVersion(int n) {
        int left=0, right=n-1;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(isBadVersion(mid)==true)
            {
                right=mid-1;
            }
            else
            {
                left=mid+1;
            }
        }
        return left;
    }

題目: 33. Search in Rotated Sorted Array
類型: array, search
筆記:
binary search的變形 搜尋條件變成利用判斷哪邊有序 
1.如果中間<=右邊代表這段遞增
2.中間>=左邊代表這段遞增 
這兩個一定會有一個情況成立 因為可以想成有一個分歧點讓某個位置的遞增亂掉 而這個點一定在左或右
用這個條件判斷到遞增的那邊 再看target在哪個範圍就好 
程式碼:
    int search(vector<int>& nums, int target) {
        int left=0, right=nums.size()-1;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]==target) return mid;
            if(nums[mid]<=nums[right]) //右邊遞增
            {
                if(target>nums[mid]&&target<=nums[right]) left=mid+1;
                else right=mid-1;
            }
            else if(nums[mid]>=nums[left]) //左邊遞增
            {
                if(target<nums[mid]&&target>=nums[left]) right=mid-1;
                else left=mid+1;
            }
        }
        return -1;
    }

題目: 81. Search in Rotated Sorted Array II
類型: array, search
筆記:
跟上一題類似 增加重複項的處理 當left=mid=right時left++ right--就不用遇到例外就O(n)
程式碼:
    bool search(vector<int>& nums, int target) {
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r)
        {
            int mid = l + (r-l) / 2;
            if (nums[mid] == target)
                return true;
            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))
            {
                l++;
                r--;
            }
            else if(nums[l] <= nums[mid])
            {
				// target is in first  half
                if((nums[l] <= target) && (nums[mid] > target))
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else
            {
                if((nums[mid] < target) && (nums[r]>= target))
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return false;
    }

題目: 162. find peak element
類型: array, search
筆記:
找峰值也可以利用binary search 判斷式用mid>mid+1&&mid>mid-1
程式碼:
    int findPeakElement(vector<int>& nums) {
        int left=0, right=nums.size()-1;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(mid!=nums.size()-1 && nums[mid]<nums[mid+1]) left=mid+1;
            else if(mid!=0 && nums[mid]<nums[mid-1]) right=mid-1;
            else return mid;
        }
        return left;
    }

題目: 42. Trapping Rain Water
類型: array, algorithm
筆記:
中間的水量是由左右的最大值中取比較小的那個 再扣掉當下的高度
紀錄left_max和right_max 縮的時候遇到比較小的就+max(l,r)-height[i] 大的就更新max
移動時移動比較矮的那邊 因為決定水高的是最大值比較小的那邊 所以小的那邊要先移動
程式碼:
    int trap(vector<int>& height) {
        int left=0, right=height.size()-1;
        int ans=0, leftmax=height[left], rightmax=height[right];
        while(left<right)
        {
            if(height[left]>leftmax) leftmax=height[left];
            else if(height[left]<leftmax) ans=ans+leftmax-height[left];
            //
            if(height[right]>rightmax) rightmax=height[right];
            else if(height[right]<rightmax) ans=ans+rightmax-height[right];
            //
            if(leftmax<rightmax) ++left;
            else --right;
        }
        return ans;
    }

題目: 55. jump game
類型: array, greedy
筆記:
greedy 用max(剩餘步數,nums[i])決定還能走多遠
程式碼:
    bool canJump(vector<int>& nums) {
        int leftjump=1;
        for(int i=0;i<nums.size();++i)
        {
            
            leftjump--;
            if(leftjump==-1) return false;
            if(nums[i]>leftjump) leftjump=nums[i];
        }
        return true;
    }

題目: 134. Gas Station
類型: array, greedy
筆記:
先gas-cost就只需要處理一個陣列 跑一個O(n)就好 總和<0後從下一個開始重跑
程式碼:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total = 0, currSum = 0, start = 0;
        for (int i = 0; i < gas.size(); ++i) {
            int remain = gas[i] - cost[i];
            total += remain;
            currSum += remain;
            if (currSum < 0) { 
                start = i + 1;
                currSum = 0;
            }
        }
        return total >= 0 ? start : -1;
    }

題目: 169. majority element
類型: array, algorithm
筆記:
題目有規定眾數為n/2以上的情況 所以可以只維護一個candidate和count 
跑到自己就++count 別的數就--count count=0時換candidate 
數量>n/2的情況下算出來的candidate一定會是答案
程式碼:
    int majorityElement(vector<int>& nums) {
        int cand=nums[0];
        int count=1;
        for(int i=1;i<nums.size();++i)
        {
            if(cand==nums[i]) ++count;
            else
            {
                if(count>0) --count;
                else
                {
                    cand=nums[i];
                    count=1;
                }
            }
        }
        return cand;

    }

題目: 48. rotate image
類型: matrix, math
筆記:
這題想要把方陣轉90 180 270度 都可以透過轉置和翻轉矩陣做到
像90度 => 先轉置1次再翻轉1次
程式碼:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n-1;++i)
        {
            for(int j=i+1;j<n;++j)
            {
                int keep = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = keep;
            }
        }
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<n/2;++j)
            {
                int keep = matrix[i][j];
                matrix[i][j] = matrix[i][n-1-j];
                matrix[i][n-1-j] = keep;
            }
        }
    }

題目: 189. rotate array 
類型: array, algorithm
筆記:
這題要把array向後轉k次 可以不用kO(n) 2個O(n)就能做到 
1)先整個array翻轉 2)翻轉前面k個 3)翻轉後面n-k個
程式碼:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        if(k>n) k=k%n;
        if(k!=0){
        for(int i=0;i<n/2;++i)
        {
            int keep=nums[i];
            nums[i]=nums[n-1-i];
            nums[n-1-i]=keep;
        }
        for(int i=0;i<k/2;++i)
        {
            int keep=nums[i];
            nums[i]=nums[k-i-1];
            nums[k-i-1]=keep;
        }
        for(int i=0; i < (n-k)/2; ++i)
        {
            int keep = nums[k+i];
            nums[k+i] = nums[n-1-i];
            nums[n-1-i] = keep;
        }
        }
    }

題目: 396. rotate function
類型: array, algorithm
筆記:
每往右一次就是左邊的全部加一次 再扣最右邊的n-1次
就等同於全部加一次 再扣最右邊的n次 這樣避免了額外空間花費和O(n)時間 只要一次減法就好
程式碼:
    int maxRotateFunction(vector<int>& nums) {
        int sum=0;
        int n=nums.size();
        for(int i=0;i<n;++i)
        {
            sum=sum+nums[i];
        }
        int now=0;
        for(int i=0;i<n;++i)
        {
            now=now+nums[i]*i;
        }
        int ans=now;
        for(int i=n-1;i>=0;--i)
        {
            now=now+sum-nums[i]*n;
            if(now>ans) ans=now;
        }
        return ans;
    }

題目: 41. find missing positive
類型: array algorithm
筆記:
O(n)時間O(1)空間找到最小不在陣列裡的正整數 
利用原地排序法 => 用一個for迴圈跑 每次swap把跑到的值swap到正確的位置
for裡面會用while迴圈判斷而不適用if是要考慮換過來的值可能要再換一次 
而且需要判斷swap的值不相等再swap 不然會無限迴圈
程式碼:
    int firstMissingPositive(vector<int>& nums) {
        int n=nums.size();
        for(int i=0;i<n;++i)
        {
            while(nums[i]!=i+1 && nums[i]>0 && nums[i]<=n && nums[i] != nums[nums[i] - 1])
            {
                swap(nums[i],nums[nums[i]-1]);
                
            }
        }
        for(int i=0;i<n;++i)
        {
            if(nums[i]!=i+1) return i+1;
        }
        return n+1;
    }

題目: 135. candy
類型: array algorithm
筆記:
這題要確保兩側的rating大於自己時 兩側的人要拿到比自己多糖果
利用左往右跑一次 右往左跑一次 取最大值來做
左往右跑的時候確保了右邊大於左邊的正確性 右往左跑也會確認左邊大於右邊的正確性 
右往左跑時取max確保同時成立
程式碼:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> can(n, 1);
        for (int i = 1; i < n; ++i) {
            if (ratings[i] > ratings[i - 1]) {
                can[i] = can[i - 1] + 1;
            }
        }
        for (int i = n - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i + 1]) {
                can[i] = max(can[i], can[i + 1] + 1);
            }
        }
        return accumulate(can.begin(), can.end(), 0);
    }

題目: 289. game of life
類型: matrix, dynamic programming
筆記:
有辦法在原地操作 不用額外開matrix 原本需要再開一個空間存的有時候可以多增加幾個狀態來表示原本的狀態
這題如果只有01代表死活 更改後可以用多幾個狀態 像是2代表死變活 -1代表活變死 
處理時就可以避免分不出來是改變前就是這個值或是他是被改後才變的
程式碼:
    int count(vector<vector<int>>& arr, int y, int x)
    {
        int k=0;
        if(x-1>=0 && y+1<arr.size() && arr[y+1][x-1]==1) ++k;
        if(x-1>=0 && arr[y][x-1]==1) ++k;
        if(x-1>=0 && y-1>=0 && arr[y-1][x-1]==1) ++k;
        if(y+1<arr.size() && arr[y+1][x]==1) ++k;
        if(y-1>=0 && arr[y-1][x]==1) ++k;
        if(x+1<arr[0].size() && arr[y][x+1]==1) ++k;
        if(x+1<arr[0].size() && y-1>=0 && arr[y-1][x+1]==1) ++k;
        if(x+1<arr[0].size() && y+1<arr.size() && arr[y+1][x+1]==1) ++k;
        return k;
    }
    void gameOfLife(vector<vector<int>>& board) {
        vector<vector<int>> temp = board;
        for(int i=0;i<board.size();++i)
        {
            for(int j=0;j<board[0].size();++j)
            {
                temp[i][j]=count(board,i,j);
            }
        }

        for(int i=0;i<board.size();++i)
        {
            for(int j=0;j<board[0].size();++j)
            {
                if(board[i][j]==0)
                {
                    if(temp[i][j]==3) board[i][j]=1;
                }
                else
                {
                    if(temp[i][j]<2) board[i][j]=0;
                    if(temp[i][j]>3) board[i][j]=0;
                }
            }
        }

    }

題目: 322. coin chagne
類型: array, dynamic programming
筆記:
經典的dp題目 找到遞迴關係以後bottom up往上跑
程式碼:
    int coinChange(vector<int>& coins, int amount) {
        vector<int>ans(amount+1,99999);
        ans[0]=0;
        for(int i=0;i<coins.size();++i) 
        {
            if(coins[i]<=amount)ans[coins[i]]=1;
        }
        for(int i=1;i<=amount;++i)
        {
            if(ans[i]==99999)
            {
                int min1=99999;
                for(int j=0;j<coins.size();++j)
                {
                    if(i-coins[j]>=0 && ans[i-coins[j]]!=99999)
                    {
                        int temp= ans[i-coins[j]] +1;
                        if(temp<min1) min1=temp;
                    }
                }
                ans[i]=min1;
            }
        }
        if(ans[amount]==99999) return -1;
        return ans[amount];
    }

題目: 997. find the town judge
類型: graph 
筆記:
可以正常跑兩個for迴圈檢查每一個人 1.有被他人信任就跳過 2.count紀錄被多少人信任 
第二個方法是紀錄(被信任次數-信任人次數) 只要迴圈跑過一遍edge改變有關的點就好
程式碼:
    int findJudge(int n, vector<vector<int>>& trust) {
    //int trust[a][b]
    for(int j=1;j<=n;++j) //檢查j有沒有相信人
    {
        int count=0; //計算相信j的人數
        for(int i=0;i<trust.size();++i) //跑過每一個edge
        {
            if(trust[i][0]==j)
            {
                count=0;
                break;
            }
            if(trust[i][1]==j) ++count;
        }
        if(count==n-1) return j;
    }
    return -1;
    }

題目: 1971. find if path exists in graph
類型: graph
筆記:
先將圖轉為adjacency list再做BFS 可以從O(n^2)變成O(edge) 要注意雙向圖轉換adjacency list時需要考慮兩邊
程式碼:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        queue<int> q;
        q.push(source);
        vector<int> visit(n,0);
        visit[source]=1;
        if(source==destination) return true;
        vector<vector<int>> adj(n);
        for(int i=0;i<edges.size();++i)
        {
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]); //雙向
        }
        while(!q.empty())
        {
            int now=q.front();
            if(now==destination) return true;
            q.pop();
            for(int i=0;i<adj[now].size();++i)
            {
                if(visit[ adj[now][i] ]==0)
                {
                    q.push(adj[now][i]);
                    visit[adj[now][i]]=1;
                }
            }
        }
        return false;
    }

題目: 547. number of provinces
類型: graph
筆記:
對visit掃過一遍 看未visit過的就好 
大部分情況用adjacency list更好 因為通常是稀疏圖 edge數比N^2少很多
程式碼:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n=isConnected.size();
        vector<int> visit(n,0);
        int ans=0;
        for(int i=0;i<n;++i)
        {
            if(visit[i]==0)
            {
                ++ans;
                queue<int> q;
                q.push(i);
                visit[i]=1;
                while(!q.empty())
                {
                    int now=q.front();
                    q.pop();
                    for(int j=0;j<n;++j)
                    {
                        if(visit[j]==0 && isConnected[now][j]==1)
                        {
                            visit[j]=1;
                            q.push(j);
                        }
                    }
                }
            }
        }
        return ans;
    }

題目: 200. number of islands
類型: grpah
筆記:
matrix上的搜尋可以用direction vector去減少需要寫的條件 ex: 
vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; 
x2=x+directions[i][0] 再對x2檢查範圍 y2也是一樣的概念 
程式碼:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty()) return 0; 
        int m = grid.size(), n = grid[0].size();
        int ans = 0;
        vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    ++ans;
                    queue<pair<int, int>> q;
                    q.push({i, j});
                    grid[i][j] = '0';
                    while (!q.empty()) {
                        auto now = q.front(); q.pop();
                        int x = now.first, y = now.second;
                        for (const auto& d : directions) {
                            int nx = x + d[0], ny = y + d[1];
                            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == '1') {
                                grid[nx][ny] = '0';
                                q.push({nx, ny});
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }

題目: 542. 01 matrix
類型: graph
筆記:
對一個matrix要對每個1計算最近的0的距離
這題從1下手會很麻煩 需要維護depth還有確保路徑最短 
從0開始往外延伸會更簡單 每輪往沒走過的部分擴展 可以確保每輪最短路徑能到的範圍 這方法是多源BFS
創一個distance陣列 原始為0的部分dist=0 往外擴展 
下一步為上一步的dis+1 來做到算距離的效果
程式碼:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};
        vector<vector<int>> dist(mat.size(),vector<int>(mat[0].size(),-1));
        queue<pair<int,int>> q;
        for(int i=0;i<mat.size();++i)
        {
            for(int j=0;j<mat[0].size();++j)
            {
                if(mat[i][j]==0)
                {
                    dist[i][j]=0;
                    q.push({i,j});
                }
            }
        }
        while(!q.empty())
        {
            pair<int,int> now=q.front();
            q.pop();
            for(int i=0;i<4;++i)
            {
                if(now.first+dir[i][0]>=0&&now.first+dir[i][0]<mat.size()&&now.second+dir[i][1]>=0&&now.second+dir[i][1]<mat[0].size()&&dist[now.first+dir[i][0]][now.second+dir[i][1]]==-1)
                {
                    dist[now.first+dir[i][0]][now.second+dir[i][1]]=dist[now.first][now.second]+1;
                    q.push({now.first+dir[i][0], now.second+dir[i][1]});
                }
            }
        }
        return dist;
    }

題目: 994. rotting oranges
類型: graph
筆記:
和上一題類似 多加幾個狀態而已
程式碼:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> dist(grid.size(), vector<int>(grid[0].size(),-1));
        queue<pair<int,int>> q;
        for(int i=0;i<grid.size();++i) //find rotten oranges and put into queue
        {
            for(int j=0;j<grid[0].size();++j)
            {
                if(grid[i][j]==0) dist[i][j]=-2;
                if(grid[i][j]==2) 
                {
                    dist[i][j]=0;
                    q.push({i,j});
                }
            }
        }
        int ans=0;
        vector<vector<int>> dir={{1,0},{0,1},{-1,0},{0,-1}};
        while(!q.empty())
        {
            pair<int,int> now=q.front();
            q.pop();
            int x=now.first;
            int y=now.second;
            for(int i=0;i<4;++i)
            {
                if(x+dir[i][0]>=0 && y+dir[i][1]>=0 && x+dir[i][0]<grid.size() && y+dir[i][1]<grid[0].size() && dist[x+dir[i][0]][y+dir[i][1]]==-1)
                {
                    dist[x+dir[i][0]][y+dir[i][1]]=dist[x][y]+1;
                    q.push({x+dir[i][0],y+dir[i][1]});
                    if(dist[x+dir[i][0]][y+dir[i][1]]>ans) ans=dist[x+dir[i][0]][y+dir[i][1]];
                }
            }
        }
        for(int i=0;i<grid.size();++i) //check if there is any fresh orange
        {
            for(int j=0;j<grid[0].size();++j)
            {
                if(dist[i][j]==-1) return -1;
            }
        }
        return ans;
    }

題目: 104. maximum depth of binary tree
類型: tree graph
筆記:
tree的dfs大部分都是找遞迴關係就好 其中class member的呼叫 用.是物件本身去呼叫 用->是物件的指標去呼叫
ex: TreeNode*p 要呼叫val   1. p->val 2.*p.val 這兩個都可以
程式碼:
    int maxDepth(TreeNode* root) {
        if(root==NULL) return 0;
        TreeNode* left_depth = root->left;
        TreeNode* right_depth = root->right;
        return max(maxDepth(left_depth),maxDepth(right_depth))+1;
    }

題目: 21. merge two list node
類型: tree graph
筆記:
這題merge的寫法是每次比較小的 保留小的開頭 後面(next)等於merge後面的部分
程式碼:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==NULL) return list2;
        if(list2==NULL) return list1;
        if(list1->val < list2->val)
        {
            list1->next=mergeTwoLists(list1->next, list2);
            return list1;
        }
        if(list1->val >= list2->val)
        {
            list2->next=mergeTwoLists(list2->next, list1);
            return list2;
        }
        return NULL;
    }

題目: 257. binary tree path
類型: tree graph
筆記:
利用vector<string> &ans來記錄答案 這樣在跑下層時也會記錄在同一份ans裡面
程式碼:
    void dfs(TreeNode* root, string s, vector<string> &ans)
    {
        if(root->left==NULL && root->right==NULL) 
        {
            s=s+to_string(root->val);
            ans.push_back(s);
        }
        else if(root->left==NULL)
        {
            dfs(root->right, s+to_string(root->val)+"->", ans);
        }
        else if(root->right==NULL)
        {
            dfs(root->left, s+to_string(root->val)+"->", ans);
        }
        else
        {
            dfs(root->right, s+to_string(root->val)+"->", ans);
            dfs(root->left, s+to_string(root->val)+"->", ans);
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans1;
        string s1;
        dfs(root, s1, ans1);
        return ans1;
    }

題目: 743. network delay time
類型: grpah dijkstra
筆記:
可以分為三個步驟 第一步是把題目的edge換成adjacency list去存方便後面操作 第二步是做出指定起點的dijkstra表格 從起點到每個點的最小距離 這個做法等一下再談 然後第三步是做好表格後用for迴圈跑一遍算總距離和  然後回到第二步 priority queue是為了dijkstra去做的 然後只先放入起點進去pq 再來用BFS的方式 每次取出一個已經有dist的點 如果dist比目前更小就更新沒有就不管  然後去對有連接到的點去更新距離並放入pq代表有連接到 之後就能拿來繼續往後走 然後前面有graph[u]可以用來更好的找到已u為起點的edge得到可以到達的點和距離
程式碼:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<pair<int, int>>> graph(n + 1); // adjacency list: node -> {(neighbor, weight)}
        for (auto& edge : times) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u].emplace_back(v, w);
        }
        // Dijkstra: min heap, stores {distance, node}
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        vector<int> dist(n + 1, INT_MAX); // shortest distance to each node
        dist[k] = 0;
        pq.emplace(0, k);
        while (!pq.empty()) {
            auto [d, u] = pq.top(); pq.pop();
            if (d > dist[u]) continue; // already visited with shorter path

            for (auto& [v, w] : graph[u]) {
                if (dist[v] > d + w) {
                    dist[v] = d + w;
                    pq.emplace(dist[v], v);
                }
            }
        }
        int res = 0;
        for (int i = 1; i <= n; ++i) {
            if (dist[i] == INT_MAX) return -1; // unreachable
            res = max(res, dist[i]);
        }
        return res;
    }

題目: 1514. path with maximum probability
類型: graph dijkstra
筆記:
和上一題類似 先轉成adjacency list 這題的判斷方式變成要找大的 和上一題的差別在weight怎麼使用 
要注意priority_queue內的比較方式要換成less<> 因為要找大的
程式碼:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        //先做成adjacency list
        vector<vector<pair<int, double>>> graph(n);
        for(int i=0;i<edges.size();++i)
        {
            int u=edges[i][0];
            int v=edges[i][1];
            double p=succProb[i];
            graph[u].emplace_back(v, p);
            graph[v].emplace_back(u, p);
        }
        // dijkstra
        priority_queue<pair<double, int>, vector<pair<double, int>>, less<> > pq;
        vector<double> dist(n,0);
        dist[start_node] = 1;
        pq.emplace(1,start_node); //初始化
        while(!pq.empty())
        {
            auto[p1, u] = pq.top();
            pq.pop();
            if(p1<dist[u]) continue;
            for(auto& [v, p] : graph[u])
            {
                if(dist[v]<p1*p)
                {
                    dist[v]=p1*p;
                    pq.emplace(dist[v],v);
                }
            }
        }
        return dist[end_node];
    }

題目: 787. cheapest flights within K stops
類型: graph dijkstra
筆記:
這題多了步數限制 要用多維的dist去存 避免cost高步數少的可能被覆蓋掉
程式碼:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        //先轉adjacency list 
        vector<vector<pair<int, int>>> graph(n); //graph[u]=(v,w)
        for(auto& edge: flights)
        {
            int u=edge[0];
            int v=edge[1];
            int w=edge[2];
            graph[u].emplace_back(v,w);
        }
        //dijkstra
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<> >pq; //tuple<w, v, step>
        vector<vector<int>> dist(n, vector<int>(k+2, INT_MAX));
        dist[src][0]=0;
        pq.emplace(0, src, 0); //dist=0 , src, step=0
        while(!pq.empty())
        {
            auto [w, v, step] = pq.top(); 
            pq.pop();
            for(auto&[v1, w1]: graph[v])
            {
                if(w+w1<dist[v1][step] && step<=k)
                {
                    dist[v1][step]=w+w1;
                    pq.emplace(dist[v1][step], v1, step+1);
                }
            }
        }
        int min=INT_MAX;
        for(int i=0;i<=k;++i)
        {
            if(dist[dst][i]<min) min=dist[dst][i];
        }
        if(min==INT_MAX) return -1;
        return min;
    }

題目: 1631. path with minimum effort
類型: grpah dijkstra
筆記:
這種題目可以先看是只能向右向下或4個方向都可以 如果只能右或下就可以用dp解就好 4個方向就要用dijkstra
這題和前面的差別是不用做adjacency list 直接拿height操作就好 記得把effort放在priority queue的第一個位置
程式碼:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m = heights.size(), n = heights[0].size();
        vector<vector<int>> cost(m, vector<int>(n, INT_MAX));
        cost[0][0] = 0;
        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0); // (effort, x, y)
        while(!pq.empty()) {
            auto [effort, x, y] = pq.top();
            pq.pop();
            if(x == m-1 && y == n-1) return effort;
            for(auto& d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if(nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int newEffort = max(effort, abs(heights[x][y] - heights[nx][ny]));
                    if(newEffort < cost[nx][ny]) {
                        cost[nx][ny] = newEffort;
                        pq.emplace(newEffort, nx, ny);
                    }
                }
            }
        }
    }



題目: 684. redundant connection
類型: graph, union find
筆記: 
union set是用一個vector去實作的 find和unionset構成 find是用遞迴的方式往上找到root才停 判斷root的方法是parent[x]=x
unionset則是用find找到兩個輸入點的root 如果相同代表同一個集合 不同就把root合併 
find是lazy update的 需要用到時才去更新parent 不需要每次合併都去檢查其他點會不會有問題
這題目標是找讓圖不是tree的邊 等同第一個已經在同一個集合內的edge 所以剛好可以使用union set去做
程式碼:
    vector<int> parent;
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路徑壓縮：把祖先直接指到 root
        }
        return parent[x];
    }
    bool unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return false; // 同集合，不能合併（形成環）
        parent[rootY] = rootX; // 合併
        return true;
    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        parent.resize(n + 1);
        for (int i = 1; i <= n; ++i) parent[i] = i;
        for (auto& edge : edges) {
            if (!unionSet(edge[0], edge[1])) return edge;
        }
        return {};
    }

題目: 1319. number of operations to make network connected
類型: graph, union find
筆記:
做法和上一題類似 要記錄多餘的邊數 最後計算有多少個集合 如果多餘的邊>=集合數-1就足夠補上
這種檢查圖是否為tree或多餘邊的題目可以用union find去想
程式碼:
    vector<int> parent;
    int find(int x)
    {
        if(x!=parent[x])
        {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    bool unionSet(int x, int y)
    {
        int rootx = find(x);
        int rooty = find(y);
        if(rootx == rooty) return false;
        parent[rootx]=rooty;
        return true;
    }
    int makeConnected(int n, vector<vector<int>>& connections) {
        parent = vector<int>(n);
        for(int i=0;i<n;++i) parent[i]=i;
        int cable=0;
        for(auto edge: connections)
        {
            if(!unionSet(edge[0], edge[1]))
            {
                ++cable;
            }
            
        }
        for(int i=0;i<n;++i)
        {
            parent[i]=find(i);
        }
        sort(parent.begin(), parent.end());
        int now=INT_MAX;
        int com=0;
        for(int i=0;i<n;++i)
        {
            if(now!=parent[i])
            {
                ++com;
                now=parent[i];
            }
        }
        if(com-1<=cable) return com-1; 
        return -1;
    }

題目: 399. evaluate division
類型: graph, union find
筆記:
這題除了記錄parent以外也要記錄weight parent內部的遞迴要包含更新weight
程式碼:
    unordered_map<string, string> parent;
    unordered_map<string, double> weight;
    string find(string x) {
        if (parent[x] != x) {
            string orig_parent = parent[x];
            parent[x] = find(orig_parent);
            weight[x] *= weight[orig_parent];
        }
        return parent[x];
    }
    void unionSet(string x, string y, double value) {
        if (!parent.count(x)) {
            parent[x] = x;
            weight[x] = 1.0;
        }
        if (!parent.count(y)) {
            parent[y] = y;
            weight[y] = 1.0;
        }
        string rootX = find(x);
        string rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
            // 更新權重
            weight[rootX] = value * weight[y] / weight[x];
        }
    }
    double isConnected(string x, string y) {
        if (!parent.count(x) || !parent.count(y)) return -1.0;
        if (find(x) != find(y)) return -1.0;
        return weight[x] / weight[y];
    }
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        parent.clear();
        weight.clear();
        for (int i = 0; i < equations.size(); ++i) {
            unionSet(equations[i][0], equations[i][1], values[i]);
        }
        vector<double> res;
        for (auto& q : queries) {
            res.push_back(isConnected(q[0], q[1]));
        }
        return res;
    }

題目: 207. course schedule
類型: grpah, topological sort
筆記:
先跑過一遍紀錄indegree 再從indegree為0的開始下手做bfs indegree變成0的就丟進queue
queue沒東西再去檢查是否還有indegree>0的 代表有cycle 
程式碼:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> pre(numCourses,0);
        vector<vector<int>> graph(numCourses);
        for(auto edge: prerequisites)
        {
            pre[edge[0]]++;
            graph[edge[1]].push_back(edge[0]);
        }
        //找第一個0 ingreed的
        queue<int> q;
        int i;
        for(i=0;i<numCourses;++i)
        {
            if(pre[i]==0) q.push(i);
        }
        while(!q.empty())
        {
            int now=q.front();
            q.pop();
            for(auto v : graph[now])
            {
                pre[v]--;
                if(pre[v]==0)
                {
                    q.push(v);
                }
            }
        }
        for(int j=0;j<numCourses;++j)
        {
            if(pre[j]>0) return false;
        }
        return true;
    }

題目: 210. course schedule 2
類型: graph, topological sort
筆記:
和上一題一樣 多一個vector紀錄路徑就好
程式碼:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> indegree(numCourses, 0);
        vector<vector<int>> graph(numCourses);
        for(auto edge: prerequisites)
        {
            indegree[edge[0]]++;
            graph[edge[1]].push_back(edge[0]);
        }
        //做完adjacency list和indegree
        vector<int> ans;
        queue<int> q;
        for(int i=0;i<numCourses;++i)
        {
            if(indegree[i]==0) 
            {
                q.push(i);
                ans.push_back(i);
            }
        }
        //放完indegree=0的
        while(!q.empty())
        {
            int now = q.front();
            q.pop();
            for(auto a: graph[now])
            {
                --indegree[a];
                if(indegree[a]==0)
                {
                    q.push(a);
                    ans.push_back(a);
                }
            }
        }
        if(ans.size()==numCourses) return ans;
        vector<int> zero;
        return zero;
    }

題目: 20. Valid Parentheses
類型: array, stack
筆記:
用stack 過程中遇到左括號放進來，遇到右括號如果發現stack空了或stack內最後一個東西不匹配右括弧就回傳false，最後檢查stack空了沒(有沒有多的左括弧)
程式碼:
    var isValid = function(s) {
    let arr = [];
    const map = {
        "(": ")",
        "[": "]",
        "{": "}"
    };
    for(let i=0;i<s.length;++i){
        if(s[i]=="(" || s[i]=="[" || s[i]=="{") { //左括號放進來
            arr.push(s[i]);
        }
        else{ //右括號檢查
            if(arr.length==0) return false;
            const now = arr.pop();
            if( s[i]!=map[now] ) return false;
        }
    }
    return (arr.length==0);
    };

題目: 1047. Remove All Adjacent Duplicates In String
類型: array, stack
筆記:
這題可以重複移除相鄰兩個相同字元，所以用stack去做，檢查新的等於最後一個就pop，不等於就放進來。記得檢查過程要有length=0的判斷，避免存取index=-1錯誤
程式碼:
    var removeDuplicates = function(s) {
    let stack = [];
    stack.push(s[0]);
    for(let i=1;i<s.length;++i){
        if(stack.length==0) { stack.push(s[i]); }
        else if(stack[stack.length-1]==s[i]){
            stack.pop();
        }
        else{
            stack.push(s[i]);
        }

    }
    return stack.join("");
    };

題目: 
類型:
筆記:

程式碼:


題目: 
類型:
筆記:

程式碼:


題目: 
類型:
筆記:

程式碼: